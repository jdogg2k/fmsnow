<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_g_irm_fms.FMSBudgetUtils</api_name>
        <caller_access/>
        <client_callable>true</client_callable>
        <description/>
        <name>FMSBudgetUtils</name>
        <script><![CDATA[var FMSBudgetUtils = Class.create();
FMSBudgetUtils.prototype = Object.extendsObject(global.AbstractAjaxProcessor, {

	budgetTable: FMSConstants.TABLE_BUDGET,
	bitemTable: FMSConstants.TABLE_BUDGET_ITEM,
	phaseTable: FMSConstants.TABLE_BUDGET_ITEM_PHASE,
	tranItemTable: FMSConstants.TABLE_FINANCIAL_TRANSACTION_ITEM,
	FMSUtility: new x_g_irm_fms.FMSUtilities(),              //helper utility for FMS queries
	
    getRelatedBudget: function(proj, type, fy, approved) {
        var bud = new GlideRecord(this.budgetTable);
        bud.addQuery('project_ref', proj);
        bud.addQuery('budget_type', type);
        bud.addQuery('fy', fy);
		if (approved && approved == true) {
			bud.addQuery('budget_status', 'IN', 'Submitted, Approved');
		}
		bud.orderByDesc('current');
		bud.setLimit(1);
        bud.query();
        if (!bud.hasNext()) return null;
		bud.next();
		return bud;
	},
	
	adjust: function(key, adjustPct) {
        var itm = new GlideRecord(this.bitemTable);
        itm.addQuery('budget_ref.sys_id', key);
        itm.query();
        while (itm.next()) {
            itm.budget_amt.setValue(parseFloat(itm.budget_amt) + (parseFloat(itm.budget_amt) * adjustPct));
			itm.update();
        }
        var phase = new GlideRecord(this.phaseTable);
        phase.addQuery('budget_item_ref.budget_ref.sys_id', key);
        phase.query();
        while (phase.next()) {
            phase.phase_amt.setValue(parseFloat(phase.phase_amt) + (parseFloat(phase.phase_amt) * adjustPct));
			phase.update();
        }
        return true;
    },

    updateNotes: function(key, notes) {
        var bud = new GlideRecord(this.budgetTable);
        bud.addQuery('sys_id', key);
		bud.setLimit(1);
        bud.query();
        if (!bud.hasNext()) return null;
		bud.next();
		bud.setValue('budget_notes', notes);
		return bud.update();
	},

	submit: function(key) {
        var bud = new GlideRecord(this.budgetTable);
        bud.addQuery('sys_id', key);
		bud.setLimit(1);
        bud.query();
        if (!bud.hasNext()) return null;
		bud.next();
		bud.setValue('budget_status', 'Submitted');
		bud.setValue('locked', true);
		return bud.update();
	},

    approve: function(key) {
        var bud = new GlideRecord(this.budgetTable);
        bud.addQuery('sys_id', key);
		bud.setLimit(1);
        bud.query();
        if (!bud.hasNext()) return null;
		bud.next();
		bud.setValue('budget_status', 'Approved');
		bud.setValue('locked', true);
		var budID = bud.update();
		if (this.setCurrent(key, bud.getValue('project_ref.sys_id'), bud.getValue('fy'), bud.getValue('budget_type')))
			return budID;
		else
			return null;
	},

    reject: function(key) {
        var bud = new GlideRecord(this.budgetTable);
        bud.addQuery('sys_id', key);
		bud.setLimit(1);
        bud.query();
        if (!bud.hasNext()) return null;
		bud.next();
		bud.setValue('budget_status', 'Rejected');
		bud.setValue('locked', false);
		return bud.update();
	},

    insertBudget: function(sourceID, project, type, fy, ver, rev) {
		var lastVer;
		var lastRev;
        var bud = new GlideRecord(this.budgetTable);
		if (sourceID) {
			bud.addQuery('sys_id', sourceID);
			bud.setLimit(1);
			bud.query();
			if (!bud.hasNext()) return null;
			bud.next();
			if (project == null) project = bud.project_ref;
			if (type == null) type = bud.budget_type;
			if (fy == null) fy = bud.fy;
			if (ver == null && rev == null) ver = bud.budget_version;
		}
        var newBudget = new GlideRecord(this.budgetTable);
		newBudget.project_ref = project;
		newBudget.budget_type = type;
		newBudget.fy = fy;
		newBudget.budget_status = "Working";
		if (!ver) {
			lastVer = this.FMSUtility.getScalar(this.budgetTable, 'budget_version', 'project_ref.sys_id=' + project + '^fy=' + fy + '^budget_type=' + type, 'budget_version');
			newBudget.budget_version = parseInt(lastVer) + 1;
		}
		else
			newBudget.budget_version = ver;
		if (!rev) {
			lastRev = this.FMSUtility.getScalar(this.budgetTable, 'budget_revision', 'project_ref.sys_id=' + project + '^fy=' + fy + '^budget_type=' + type + '^budget_version=' + newBudget.budget_version, 'budget_revision');
			newBudget.budget_revision = parseInt(lastRev) + 1;
		}
		else 
			newBudget.budget_revision = rev;
		newBudget.budget_source_ref = sourceID;
		newBudget.current = !this.hasCurrent(newBudget.project_ref.sys_id, newBudget.budget_type, newBudget.fy);
		if (newBudget.budget_type == "Actual")
			newBudget.locked = true;
		else
			newBudget.locked = false;
		var newID = newBudget.insert();
		return newID;
	},
	
	newRevision: function(key) {
		var newID = this.insertBudget(key, null, null, null, null, null);
		if (newID) var result = this.copyItems(key, newID);
		return newID;
	},

    newVersion: function(key) {
		var newID = this.insertBudget(key, null, null, null, null, 0);
		if (newID) var result = this.copyItems(key, newID);
		return newID;
	},

    newCopy: function(key, fy, type) {
		var newID = this.insertBudget(key, null, type, fy, null, 0);
		if (newID) var result = this.copyItems(key, newID);
		return newID;
	},

    createBudget: function(key, project, type, fy) {
		var newID;
		if (type == "Actual")
			newID = this.createActual(key, project, type, fy);
		else if (type == "Execution")
			newID = this.createExecution(key, project, type, fy);
		else
			newID = this.insertBudget(key, null, type, fy, null, 0);
		return newID;
	},
	
    createExecution: function(key, project, type, fy) {
		var newID = this.insertBudget(key, project, "Execution", fy, 1, 0);
		if (newID) var result = this.copyItems(key, newID);
		return newID;
	},

    createActual: function(key, project, type, fy) {
		var	exBud = this.getRelatedBudget(project, "Execution", fy);
		if (!exBud) {
			gs.addErrorMessage("Execution budget should be created before actual budget.");
			return null;
		}
		var newID = this.insertBudget(key, project, "Actual", fy, 1, 0);
		return newID;
	},

    lock: function(key) {
        var bud = new GlideRecord(this.budgetTable);
        bud.addQuery('sys_id', key);
		bud.setLimit(1);
        bud.query();
        if (!bud.hasNext()) return null;
		bud.next();
		bud.setValue('locked', true);
		return bud.update();
	},

    unlock: function(key) {
        var bud = new GlideRecord(this.budgetTable);
        bud.addQuery('sys_id', key);
		bud.setLimit(1);
        bud.query();
        if (!bud.hasNext()) return null;
		bud.next();
		bud.setValue('locked', false);
		return bud.update();
	},

    makeCurrent: function(key) {
        var bud = new GlideRecord(this.budgetTable);
        bud.addQuery('sys_id', key);
		bud.setLimit(1);
        bud.query();
        if (!bud.hasNext()) return null;
		var result = bud.next();
		if (this.setCurrent(key, bud.getValue('project_ref'), bud.getValue('fy'), bud.getValue('budget_type')))
			return result;
		else
			return null;
	},
	
    setCurrent: function(key, project, fy, type) {
        var bud = new GlideRecord(this.budgetTable);
        bud.addQuery('fy', fy);
        bud.addQuery('budget_type', type);
        bud.addQuery('project_ref', project);
		bud.orderByDesc('current');
        bud.query();
		var result = false;
        if (!bud.hasNext()) return result;
		while (bud.next()) {
			if (bud.getValue('sys_id') == key) {
				bud.setValue('current', true);
				result = bud.update();
			}
			else if (bud.getValue('current') != false) {
				bud.setValue('current', false);
				result = bud.update();
			}
		}
		return result;
	},
	
	copyItems: function(from, to) {
        var source = new GlideRecord(this.bitemTable);
        source.addQuery('budget_ref.sys_id', from);
		source.query();
		while (source.next()) {
			var target = new GlideRecord(this.bitemTable);
			target.initialize();
			target.budget_ref = to;
			target.expense_item_ref = source.expense_item_ref;
			target.budget_amt = source.budget_amt;
			var newItem = target.insert();
			var result = this.copyPhasing(source.sys_id, newItem);
		}		
		return true;
	},
	
	copyPhasing: function(from, to) {
        var source = new GlideRecord(this.phaseTable);
        source.addQuery('budget_item_ref', from);
		source.query();
		while (source.next()) {
			var target = new GlideRecord(this.phaseTable);
			target.initialize();
			target.budget_item_ref = to;
			target.fiscal_month = source.fiscal_month;
			target.phase_amt = source.phase_amt;
			target.insert();
		}		
		return true;
	},
	
	hasCurrent: function(project, type, fy) {
		var relBud = this.getRelatedBudget(project, type, fy);
		if (relBud == null || relBud.current != 1)
			return false;
		else
			return true;
	},
	
    updateActual: function(actualKey, executionKey) {
			//  Compare budgets and add or remove items on actual based on execution, then 
			//  Update actual with budget amount = expense amount   and   projected amount = execution budget amount - expense amount
		if (actualKey == undefined) return false;
        var bud = new GlideRecord(this.budgetTable);
        bud.addQuery('sys_id', actualKey);
		bud.setLimit(1);
        bud.query();
		bud.next();
		if (executionKey == undefined) {
			exBud = this.getRelatedBudget(bud.project_ref, "Execution", bud.fy);
			executionKey = exBud.sys_id;
		}
		gs.addInfoMessage("ex:   " + executionKey + "  act:   " + actualKey);
		var qry = "budget_ref=" + executionKey;
        var exItem = new GlideRecord(this.bitemTable);
        exItem.addEncodedQuery(qry);
		exItem.query();
		gs.addInfoMessage(' row count: ' + exItem.getRowCount());
		while (exItem.next()) {
//			gs.addInfoMessage('item: ' + exItem.expense_item_ref);
			var expTotal = this.getExpenseTotal(bud.project_ref, bud.fy, exItem.expense_item_ref);
			this.updateBudgetItem(actualKey, exItem.expense_item_ref, parseFloat(expTotal), parseFloat(exItem.budget_amt) - parseFloat(expTotal));
		}		
		this.removeUnreferenced(actualKey, executionKey);
		return true;
	},
    
    updateBudgetItem: function(budget, expense, budamt, projamt) {
		// updates or creates a budget item
		var itm = new GlideRecord(this.bitemTable);
		itm.addQuery('budget_ref', budget);
		itm.addQuery('expense_item_ref', expense);
		itm.setLimit(1);
		itm.query();
		gs.addInfoMessage('item: ' + expense);
		if (!itm.hasNext()) {    // item does not exist  
			if (!itm.canCreate()) { gs.addInfoMessage('No authority to create budget items.'); return false; }
			gs.addInfoMessage('..........inserting: ' + expense + '  budget_amt ' + budamt + '   projamt: ' + projamt);
			itm.budget_ref = budget;
			itm.expense_item_ref = expense;
			itm.budget_amt = budamt;
			itm.projected_amt = projamt;
			itm.insert();
		}
		else {
			itm.next();
			if (parseFloat(itm.budget_amt) == budamt && parseFloat(itm.projected_amt) == projamt) return true;
			if (!itm.canWrite()) { gs.addInfoMessage('No authority to update budget items.'); return false; }
			gs.addInfoMessage('..........updating: ' + expense + '  budget_amt ' + budamt + '   projamt: ' + projamt);
			itm.budget_amt = budamt;
			itm.projected_amt = projamt;
			itm.update();
		}
		return true;
	},
	
    removeUnreferenced: function(target, source) {
		// removes unreferenced items from target budget
		var qry = "budget_ref=" + source + "^ORbudget_ref=" + target;
        var nondup = new GlideAggregate(this.bitemTable);
        nondup.addEncodedQuery(qry);
        nondup.addAggregate('COUNT', 'expense_item_ref');
		nondup.groupBy('expense_item_ref');
		nondup.query();
		while (nondup.next()) {
			if (nondup.getAggregate('COUNT', 'expense_item_ref') > 1) continue;
			if (!itm.canDelete()) { gs.addInfoMessage('No authority to delete budget items.'); return false; }
			gs.addInfoMessage(' deleting: ' + nondup.expense_item_ref);
			var itm = new GlideRecord(this.bitemTable);
			itm.addQuery('budget_ref', target);
			itm.addQuery('expense_item_ref', nondup.expense_item_ref);
			itm.setLimit(1);
			itm.query();
			itm.next();
			itm.deleteRecord();
		}
		return true;
	},
	
	getExpenseTotal: function(project, fy, expense) {
		var agg = new GlideAggregate(this.tranItemTable);
		agg.addAggregate('SUM', 'item_total');
		agg.addQuery('fin_tran_ref.project_ref', project);
		agg.addQuery('fin_tran_ref.fy', fy);
		agg.addQuery('expense_item_ref', expense);
		agg.groupBy('expense_item_ref');
		agg.query();
		var expTotal = 0;
		if (agg.hasNext()) {
			agg.next();
			expTotal = agg.getAggregate('SUM', 'item_total');
		}	
//		gs.addInfoMessage('ref: ' + expense + " total: " + expTotal);
		return expTotal;
	},
	
	type: 'FMSBudgetUtils'
});]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>MarkelJR@state.gov</sys_created_by>
        <sys_created_on>2020-06-15 15:53:58</sys_created_on>
        <sys_id>07a331ef1b5d90101f7e113d9c4bcb40</sys_id>
        <sys_mod_count>181</sys_mod_count>
        <sys_name>FMSBudgetUtils</sys_name>
        <sys_package display_value="FMS" source="x_g_irm_fms">c728dd331b3fc8100a4a10ad9c4bcbb6</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="FMS">c728dd331b3fc8100a4a10ad9c4bcbb6</sys_scope>
        <sys_update_name>sys_script_include_07a331ef1b5d90101f7e113d9c4bcb40</sys_update_name>
        <sys_updated_by>MarkelJR@state.gov</sys_updated_by>
        <sys_updated_on>2020-07-01 14:16:34</sys_updated_on>
    </sys_script_include>
</record_update>
